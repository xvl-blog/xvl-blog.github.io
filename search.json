[{"title":"Atcoder-abc334_e 题解","url":"/2mpSmSBF4HsM6X5d2c2n5GNmZg87GYza/","content":"[题目传送门](https://atcoder.jp/contests/abc334/tasks/abc334_e)\n\n一道 dfs 题……\n<!--more-->\n先统计出绿连通块数量，然后对于每个红色方块统计涂成绿色方块后会变成多少个连通块。正常涂成绿色后应该会增加一个大小为 $1$ 的绿连通块，但若是有不同的绿连通块与其相邻，答案又会减少 $1$。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\nconst long long IMX = 1ll << 30;\nconst long long LMX = 1ll << 60;\nconst long long MOD = 998244353;\n\nusing ll = long long;\nusing i128 = __int128;\nusing ld = long double;\nusing f128 = __float128;\n\nnamespace xvl_ { \n\t#define SP(n, x) std :: setprecision(n) << std :: fixed << x\n\t#define REP(i, l, r) for (auto i = (l); i <= (r); i++)\n\t#define PER(i, r, l) for (auto i = (r); i >= (l); i--)\n\t#define DEBUG(x) std :: cerr << #x << \" = \" << x << '\\n'\n\t#define SZ(x) (x.size())\n\t#define fst first\n\t#define snd second\n\ttemplate <typename T> T Max(T a, T b) { return a > b ? a : b; } template <typename T, typename... Args> T Max(T a, Args... args) { return a > Max(args...) ? a : Max(args...); }\n\ttemplate <typename T> T Min(T a, T b) { return a < b ? a : b; } template <typename T, typename... Args> T Min(T a, Args... args) { return a < Min(args...) ? a : Min(args...); }\n}\nusing namespace std;\nusing namespace xvl_;\nll h, w, cnt, sum, ans;\nll dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}, id[1005][1005];\nchar c[1005][1005];\nvoid dfs(int x, int y) {\n    REP(i, 0, 3) {\n        ll sx = dir[i][0] + x, sy = dir[i][1] + y;\n        if (sx >= 1 and sy >= 1 and sx <= h and sy <= w and c[sx][sy] == '#' and !id[sx][sy]) {\n\t\t\tid[sx][sy] = cnt;\n\t\t\tdfs(sx, sy);\n\t\t}\n    }\n}\nll qpow(ll n, ll m, int p) { \n\tll res = 1;\n\twhile (m) {\n\t\tif (m & 1) res = res % p * n % p;\n\t\tn = n % p * n % p;\n\t\tm >>= 1;\n\t}\n\treturn res; \n}\nint main() {\n\t// freopen(\"InName.in\", \"r\", stdin);\n\t// freopen(\"OutName.out\", \"w\", stdout);\n\tios :: sync_with_stdio(0);\n\tcin.tie(nullptr);\n\tcin >> h >> w;\n\tREP(i, 1, h) { REP(j, 1, w) cin >> c[i][j]; }\n\tREP(i, 1, h) {\n\t\tREP(j, 1, w) {\n\t\t\tif (!id[i][j] and c[i][j] == '#') {\n\t\t\t\tcnt++;\n\t\t\t\tid[i][j] = cnt;\n\t\t\t\tdfs(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, 1, h) {\n\t\tREP(j, 1, w) {\n\t\t\tif (c[i][j] == '.') {\n\t\t\t\tsum++;\n\t\t\t\tset <int> S;\n\t\t\t\tREP(k, 0, 3) {\n\t\t\t\t\tll sx = dir[k][0] + i, sy = dir[k][1] + j;\n\t\t\t\t\tif (sx >= 1 and sy >= 1 and sx <= h and sy <= w and c[sx][sy] == '#') S.insert(id[sx][sy]);\n\t\t\t\t}\n\t\t\t\tans += cnt - S.size() + 1; // 原先的连通块数量 + 1 再减去相邻的不同的连通块\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans % MOD * qpow(sum, MOD - 2, MOD) % MOD;\n\treturn 0;\n}\n```","tags":["题解"]},{"title":"Atcoder-abc334_c 题解","url":"/2mpSmSBF4HsM6X5d2c2n5GsXDevtHL38/","content":"\n[题目传送门](https://atcoder.jp/contests/abc334/tasks/abc334_c)\n\n一道贪心题……\n<!--more-->\n数量为 $2$ 的袜子不用考虑，因为最好的情况就是相同颜色的配一对。\n\n我们只需要考虑那 $k$ 种只有 $1$ 个的袜子，如果 $k$ 为偶数，答案为相邻两数之差之和；如果 $k$ 为奇数，就枚举删掉一个数，让剩下的数按照 $k$ 为偶数的情况做，最后取一个最小值。这个过程可以使用前缀和维护。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\nconst long long IMX = 1ll << 30;\nconst long long LMX = 1ll << 60;\nconst long long MOD = 998244353;\n\nusing ll = long long;\nusing i128 = __int128;\nusing ld = long double;\nusing f128 = __float128;\n\nnamespace xvl_ { \n\t#define SP(n, x) std :: setprecision(n) << std :: fixed << x\n\t#define REP(i, l, r) for (auto i = (l); i <= (r); i++)\n\t#define PER(i, r, l) for (auto i = (r); i >= (l); i--)\n\t#define DEBUG(x) std :: cerr << #x << \" = \" << x << '\\n'\n\t#define SZ(x) (x.size())\n\t#define fst first\n\t#define snd second\n\ttemplate <typename T> T Max(T a, T b) { return a > b ? a : b; } template <typename T, typename... Args> T Max(T a, Args... args) { return a > Max(args...) ? a : Max(args...); }\n\ttemplate <typename T> T Min(T a, T b) { return a < b ? a : b; } template <typename T, typename... Args> T Min(T a, Args... args) { return a < Min(args...) ? a : Min(args...); }\n}\nusing namespace std;\nusing namespace xvl_;\nll n, k, ans;\nll a[200005], sum[200005], pre[200005];\nint main() {\n\t// freopen(\"InName.in\", \"r\", stdin);\n\t// freopen(\"OutName.out\", \"w\", stdout);\n\tios :: sync_with_stdio(0);\n\tcin.tie(nullptr);\n\tcin >> n >> k;\n\tREP(i, 1, k) {\n\t\tcin >> a[i];\n\t\tif (i & 1) sum[i] = sum[i - 1] - a[i];\n\t\telse sum[i] = sum[i - 1] + a[i];\n\t}\n\tPER(i, k, 1) {\n\t\tif (i & 1) pre[i] = pre[i + 1] - a[i];\n\t\telse pre[i] = pre[i + 1] + a[i];\n\t}\n\tif (k & 1) {\n\t\tans = LMX;\n\t\tREP(i, 1, k) ans = Min(ans, sum[i - 1] - pre[i + 1]);\n\t}\n\telse {\n\t\tfor (int i = 2; i <= n; i += 2) ans += a[i] - a[i - 1];\n\t}\n\tcout << ans;\n\treturn 0;\n}\n```\n","tags":["题解"]},{"title":"Atcoder-abc254_e 题解","url":"/2mpSmSBF4HsM6X5d173cqY3VrBrad8pz/","content":"[题目传送门](https://atcoder.jp/contests/abc254/tasks/abc254_e)\n\n一道暴力题……\n<!--more-->\n度数和 $k$ 那么小？直接暴力 $n$ 遍 bfs，注意 bfs 的队列只能 `push` 距离不超过 $3$ 的点。但有个问题，每次 bfs 都需要清空一次距离数组，这样子的时间复杂度是 $O(n^2)$ 的。但也不难想到，距离数组中被赋值的地方不会很多，记录一下就行。\n\n### Code\n```cpp\n#include <bits/stdc++.h>\n\nconst long long IMX = 1ll << 30;\nconst long long LMX = 1ll << 60;\nconst long long MOD = 998244353;\n\nusing ll = long long;\nusing i128 = __int128;\nusing ld = long double;\nusing f128 = __float128;\n\nnamespace xvl_ { \n\t#define SP(n, x) std :: setprecision(n) << std :: fixed << x\n\t#define REP(i, l, r) for (auto i = (l); i <= (r); i++)\n\t#define PER(i, r, l) for (auto i = (r); i >= (l); i--)\n\t#define DEBUG(x) std :: cerr << #x << \" = \" << x << '\\n'\n\t#define SZ(x) (x.size())\n\t#define fst first\n\t#define snd second\n\ttemplate <typename T> T Max(T a, T b) { return a > b ? a : b; } template <typename T, typename... Args> T Max(T a, Args... args) { return a > Max(args...) ? a : Max(args...); }\n\ttemplate <typename T> T Min(T a, T b) { return a < b ? a : b; } template <typename T, typename... Args> T Min(T a, Args... args) { return a < Min(args...) ? a : Min(args...); }\n}\nusing namespace std;\nusing namespace xvl_;\nstruct Node { ll id, cnt; };\nll n, m, q;\nll dis[150005];\nvector <int> G[150005];\nvector <pair <int, int>> D[150005];\n// first 代表编号，second 代表步数\nvoid bfs(ll s) {\n\tif (s == 1) fill(dis + 1, dis + 1 + n, IMX);\n\telse for (auto v : D[s - 1]) dis[v.fst] = IMX;\n\tqueue <Node> q;\n\tvector <int> p;\n\tq.push({s, 0}), dis[s] = 0;\n\twhile (!q.empty()) {\n\t\tNode cur = q.front();\n\t\tq.pop();\n\t\tfor (auto v : G[cur.id]) {\n\t\t\tif (cur.cnt + 1 < dis[v] and cur.cnt + 1 <= 3) {\n\t\t\t\tdis[v] = cur.cnt + 1;\n\t\t\t\tp.push_back(v);\n\t\t\t\tq.push({v, dis[v]});\n\t\t\t}\n\t\t}\n\t}\n\tD[s].push_back(make_pair(s, 0));\n\tfor (auto v : p) {\n\t\tif (dis[v] <= 3) D[s].push_back(make_pair(v, dis[v]));\n\t}\n}\nint main() {\n\t// freopen(\"InName.in\", \"r\", stdin);\n\t// freopen(\"OutName.out\", \"w\", stdout);\n\tios :: sync_with_stdio(0);\n\tcin.tie(nullptr);\n\tcin >> n >> m;\n\tREP(i, 1, m) {\n\t\tll u, v;\n\t\tcin >> u >> v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tREP(i, 1, n) bfs(i);\n\tcin >> q;\n\twhile (q--) {\n\t\tll x, k, ans = 0;\n\t\tcin >> x >> k;\n\t\tfor (auto v : D[x]) {\n\t\t\tif (v.snd <= k) ans += v.fst;\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\treturn 0;\n}\n```","tags":["题解"]},{"title":"Atcoder-abc326_c 题解","url":"/2mpSmSBF4HsM6X5d2bM6pNSmqDAZbBeD/","content":"[题目传送门](https://atcoder.jp/contests/abc326/tasks/abc326_c)\n\n一道二分题……\n<!--more-->\n首先非常显然，你选择的这个区间左端点在 $a_i$ 上肯定更优，因此我们可以枚举左端点 $l$。然后剩下的就是使用二分求出有多少个 $a_i$ 满足 $l\\le a_i< l+m$，具体可以使用 `std :: upper_bound` 实现。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\nconst long long IMX = 1ll << 30;\nconst long long LMX = 1ll << 60;\n\ntypedef long long ll;\ntypedef __int128 i128;\ntypedef long double ld;\ntypedef __float128 f128;\n\nnamespace xvl_ { \n\t#define SP(n, x) std :: setprecision(n) << std :: fixed << x\n\t#define REP(i, l, r) for (auto i = (l); i <= (r); i++)\n\t#define PER(i, r, l) for (auto i = (r); i >= (l); i--)\n\t#define DEBUG(x) std :: cerr << #x << \" = \" << x << '\\n'\n\ttemplate <typename T> T Max(T a, T b) { return a > b ? a : b; } template <typename T, typename... Args> T Max(T a, Args... args) { return a > Max(args...) ? a : Max(args...); }\n\ttemplate <typename T> T Min(T a, T b) { return a < b ? a : b; } template <typename T, typename... Args> T Min(T a, Args... args) { return a < Min(args...) ? a : Min(args...); }\n}\nusing namespace std;\nusing namespace xvl_;\nll n, m, ans;\nint a[300005];\nint main() {\n\t// freopen(\"InName.in\", \"r\", stdin);\n\t// freopen(\"OutName.out\", \"w\", stdout);\n\tios :: sync_with_stdio(0);\n\tcin.tie(nullptr);\n\tcin >> n >> m;\n\tREP(i, 1, n) cin >> a[i];\n\tsort(a + 1, a + 1 + n);\n\tREP(i, 1, n) {\n\t\tll loc = upper_bound(a + 1, a + 1 + n, a[i] + m - 1) - a - 1;\n\t\tans = Max(ans, loc - i + 1);\n\t}\n\tcout << ans;\n\treturn 0;\n}\n```\n","tags":["题解"]},{"title":"洛谷-P9749 题解","url":"/JeEb5hYmQiFpc8bhvTssniyFq8/","content":"[题目传送门](https://www.luogu.com.cn/problem/P9749)\n\n一道 dp 题……\n<!--more-->\n好像大家写的都是贪心，这里给出一种 dp 的写法。\n\n在 dp 之前，我们需要明确以下几个东西：\n\n**状态的表示**，**状态转移方程**，**边界条件**跟**答案的表示**。\n\n### 状态的表示\n\n$dp_i$ 表示到达第 $i$ 个站点所需要的最少钱数，$w_i$ 表示在使用最少钱数到达第 $i$ 个站点时多余的路程。\n\n### 状态转移方程\n\n$$dp_i=dp_{i-1}+\\lceil\\frac{v_{i-1}-w_{i-1}}{d}\\rceil\\times pre\\_min(i-1)$$\n$$w_i=\\lceil\\frac{v_{i-1}-w_{i-1}}{d}\\rceil-v_{i-1}+w_{i-1}$$\n\n其中 $pre\\_min(i)$ 表示前 $i$ 个站点中最小的油价。\n\n### 边界条件\n\n$$dp_i=0$$\n$$w_i=0$$\n\n### 答案的表示\n\n$$dp_n$$\n\n### Code\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nll n, d, ans;\nll v[100005], a[100005], dp[100005], pm[100005], w[100005];\nint main() {\n\t// freopen(\"road.in\", \"r\", stdin);\n\t// freopen(\"road.out\", \"w\", stdout);\n\tios :: sync_with_stdio(0);\n\tcin >> n >> d;\n\tpm[0] = 1e18;\n\tfor (int i = 1; i < n; i++) cin >> v[i];\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t\tpm[i] = min(pm[i - 1], a[i]);\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tdp[i] = dp[i - 1] + ceil(1.0 * (v[i - 1] - w[i - 1]) / d) * pm[i - 1];\n\t\tw[i] = ceil(1.0 * (v[i - 1] - w[i - 1]) / d) * d - (v[i - 1] - w[i - 1]);\n\t}\n\tcout << dp[n];\n\treturn 0;\n}\n\n```","tags":["题解"]},{"title":"CodeForces-1800F 题解","url":"/2oMtwNqsh8bCr3r6Mw5TCz1eX8iNXDVn/","content":"[题目传送门](https://codeforces.com/problemset/problem/1800/F)\n\n一道字符串题……\n<!--more-->\n既然两个字符串拼接后有一种字符不能出现，那么可以枚举这个字符，我们就只需要关注没有出现过这种字符的字符串了。\n\n剩下的字符串仅会出现 $25$ 种字符，而我们并不关心字符串里字符的顺序，仅关心字符出现的个数的奇偶性，因此我们可以把字符串看做是一个长度为 $25$ 的二进制数 $x_i$，如果某一位为 $1$ 表明这种字符在字符串中的出现次数为奇数，如果某一位为 $0$ 则表明为偶数。\n\n那么接下来题目就转变为有多少对 $i,j$ 满足 $x_i\\oplus x_j =2^{25}-1$，可以使用 `std :: map` 统计。\n\n### Code\n```cpp\n#include <bits/stdc++.h>\n\nconst long long IMX = 1ll << 30;\nconst long long LMX = 1ll << 60;\n\ntypedef long long ll;\ntypedef __int128 i128;\ntypedef long double ld;\ntypedef __float128 f128;\n\nnamespace xvl_ { \n\t#define SP(n, x) std :: setprecision(n) << std :: fixed << x\n\t#define REP(i, l, r) for (auto i = (l); i <= (r); i ++)\n\t#define PER(i, r, l) for (auto i = (r); i >= (l); i --)\n\t#define DEBUG(x) std :: cerr << #x << \" = \" << x << '\\n'\n\ttemplate <typename T> T Max(T a, T b) { return a > b ? a : b; } template <typename T, typename... Args> T Max(T a, Args... args) { return a > Max(args...) ? a : Max(args...); }\n\ttemplate <typename T> T Min(T a, T b) { return a < b ? a : b; } template <typename T, typename... Args> T Min(T a, Args... args) { return a < Min(args...) ? a : Min(args...); }\n}\nusing namespace std;\nusing namespace xvl_;\nll n, ans;\nll cnt[200005][26];\nstring s[200005];\nvector <ll> x;\nmap <ll, ll> mp;\nint main() {\n\t// freopen(\"InName.in\", \"r\", stdin);\n\t// freopen(\"OutName.out\", \"w\", stdout);\n\tios :: sync_with_stdio(0);\n\tcin.tie(nullptr);\n\tcin >> n;\n\tREP(i, 1, n) {\n\t\tcin >> s[i];\n\t\tREP(j, 0, s[i].size() - 1) cnt[i][s[i][j] - 'a'] ++;\n\t}\n\tREP(c, 0, 25) {\n\t\tmp.clear(), x.clear();\n\t\tREP(i, 1, n) {\n\t\t\tif (cnt[i][c]) continue;\n\t\t\tx.push_back(0);\n\t\t\tREP(j, 0, 25) {\n\t\t\t\tif (j == c) continue;\n\t\t\t\tx[x.size() - 1] = (x[x.size() - 1] << 1) | (cnt[i][j] & 1);\n\t\t\t}\n\t\t}\n\t\tfor (auto v : x) {\n\t\t\tmp[v] ++;\n\t\t\tans += mp[v ^ (1 << 25) - 1];\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}\n```","tags":["题解"]},{"title":"CSP 2023 游记","url":"/2TfhDqWaSFXNdF3PiGDKf/","content":"### Day -35\n\n初赛，不在状态。看到了一车的小学生，虽然我也是。\n\nJ 78 pts，S 61 pts，不知道 S 为啥那么高，总之两个都过了。\n\n### Day -20 ~ -16\n\n国庆来到 GF 集训，面到了 @[VitrelosTia](https://www.luogu.com.cn/user/672333)，看见了非常有实力又有 $6$ 级勾又 AK 了 CSP-J 的学长 lbw。\n\n### Day -1\n\n没干什么。\n<!--more-->\n### Day 0\n\n早上考 J。\n\n有点冷，穿了短袖+两件外套，考场是艺术楼，发现是小学生考场。\n\n发压缩包，解压了很久没解压出来，发现解压密码里的数字 $1$ 是小写字母 $l$。\n\n开 T1，看起来是结论题，于是暴力打了个表，疯狂找规律，结果搞了 $2$ 个小时，直接爆炸。最后第二个答案随便乱写了个东西。\n\n非常难受，先看 T2。看上去第一眼像是 dp，但是感觉 CCF 应该不会将 dp 放 T2，但是最后还是写了，30 min 过了大样例。\n\n具体就是 $dp_i$ 表示走到第 $i$ 个站点所需的最少花费，然后求了个前缀最小值 $pm$，又搞了 $w_i$ 用来存到达 $i$ 号站点有多少多余的路程。然后就 $dp_i=dp_{i-1}+\\lceil\\frac{v_{i-1}-w_{i-1}}{d}\\rceil\\times pm_{i-1}$，$w_i=\\lceil\\frac{v_{i-1}-w_{i-1}}{d}\\rceil-v_{i-1}+w_{i-1}$。\n\n感觉学 dp 学魔怔了，J 组 T2 写 dp。\n\nT3 大模拟，不想写，跳了。\n\n看 T4，看到是图论，不会，于是输出 $-1$ 又滚回 T3。\n\n看到 T3 B 和 C 性质分很多，于是写了，大概 60 pts。\n\n最终 J 估分：100 + 100 + 60 + 10 = 270。\n\nluogu 自测：70 + 100 + 50 + 10 = 230。\n\n感觉 J 寄了。\n\n中午吃火锅。\n\n下午 S，好像要下雨，往包里塞了把伞。\n\n开 T1，发现是 dfs，用了 40min 过了大样例。\n\n看了看 T2，感觉又是 dp，想写个 $O(n^3)$ 的区间 dp，没写出来，太弱了。\n\n甚至没想到是括号匹配。\n\n开 T3 发现又是大模拟，题意太长没看，于是写了个「不可以，总司令」就去看 T4 了。\n\n这里居然没看到 T3 的简化版题意。\n\nT4 感觉 B 性质挺好做，毕竟每天选择生长的树是唯一的，于是写了个二分，在草稿纸上推了推式子，啥都没想出来。\n\n然后就啥也不会，摆了，摆到结束。\n\n拿个 2= 够了。\n\n最终 S 估分：100 + 0 + 0 + 0 = 100。\n\nluogu 自测：100 + 0 + 0 + 0 = 100。\n\n### Day 1\n\n感觉要退役了，不过我好像是小学生？希望 CCF 的数据水点。","tags":["游记"]},{"title":"AtCoder-abc118_d 题解","url":"/2mpQoKaYxUnSVo4toEcDuFuNPKsCCdzr/","content":"[题目传送门](https://atcoder.jp/contests/abc118/tasks/abc118_d)\n\n一道 dp 题……\n<!--more-->\n在 dp 之前，我们需要明确以下几个东西：\n\n**状态的表示**，**状态转移方程**，**边界条件**跟**答案的表示**。\n\n### 状态的表示\n\n$dp_i$ 表示恰好用完 $i$ 根火柴能拼出来的最大数字。\n\n### 状态转移方程\n\n$$dp_i = \\max\\{j \\times 10^{len(dp_{i-w_j})} + dp_{i-w_j}\\}$$\n\n其中 $len(n)$ 表示 $n$ 的位数，$w_i$ 表示拼出数字 $i$ 所需的火柴数量。实际上这里是将 $dp_{i-w_j}$ 拼在 $j$ 后面。\n\n### 边界条件\n\n$$dp_i = 0$$\n\n### 答案的表示\n\n$$dp_n$$\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nll n, m;\nll w[10] = {0, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nstring dp[10005];\nbool vis[10];\nstring strmax(string x, string y) {\n\tif (x.size() > y.size()) return x;\n\tif (x.size() < y.size()) return y;\n\tfor (int i = 0; i < x.size(); i++) {\n\t\tif (x[i] < y[i]) return y;\n\t\tif (y[i] < x[i]) return x;\n\t}\n}\nll sum(string s) {\n\tll res = 0;\n\tfor (int i = 0; i < s.size(); i++) res += w[s[i] - '0'];\n\treturn res;\n}\nint main() {\n\tios :: sync_with_stdio(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; i++) {\n\t\tll x;\n\t\tcin >> x;\n\t\tvis[x] = 1;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= 9; j++) {\n\t\t\tif (vis[j] and i >= w[j] and sum(to_string(j) + dp[i - w[j]]) == i) dp[i] = strmax(dp[i], to_string(j) + dp[i - w[j]]);\n\t\t}\n\t}\n\tcout << dp[n];\n\treturn 0;\n}\n```\n","tags":["题解"]},{"title":"AtCoder-abc234_e 题解","url":"/2mpQoKaYxUnSVo4tpLb7RXMy4aRJiPSc/","content":"[题目传送门](https://atcoder.jp/contests/abc234/tasks/abc234_e)\n\n一道枚举题……\n<!--more-->\n暴力枚举数字位数、首位、等差数列的公差即可。注意公差的枚举范围，并且需要看看末尾合不合法。顺便提一下，我是用字符串存储枚举的数字的，所以写了一个 `check` 函数代替大于号。\n\n### Code\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nll x;\nll top_num(ll x) { ll res; while (x) res = x % 10, x /= 10; return res; }\nll len(ll x) { ll res = 0; while (x) res++, x /= 10; return res; }\nbool check(string a, string b) {\n\tif (a.size() > b.size()) return 1;\n\tif (a.size() < b.size()) return 0;\n\tfor (int i = 0; i < a.size(); i++) {\n\t\tif (a[i] - '0' > b[i] - '0') return 1;\n\t\tif (a[i] - '0' < b[i] - '0') return 0;\n\t}\n\treturn 1;\n}\nint main() {\n\tios :: sync_with_stdio(0);\n\tcin >> x;\n\tfor (ll i = len(x); i; i++) {\n\t\tfor (ll j = top_num(x); j <= 9; j++) {\n\t\t\tfor (ll d = -10; d <= 10; d++) {\n\t\t\t\tstring s = to_string(j);\n\t\t\t\tif (j + (i - 1) * d >= 0 and j + (i - 1) * d <= 9) {\n\t\t\t\t\tfor (ll k = 1; k < i; k++) s += to_string(j + k * d);\n\t\t\t\t}\n\t\t\t\tif (check(s, to_string(x))) {\n\t\t\t\t\tcout << s;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n","tags":["题解"]},{"title":"AtCoder-abc231_e 题解","url":"/2mpQoKaYxUnSVo4tpLaX5YxEWRDsUaCp/","content":"[题目传送门](https://atcoder.jp/contests/abc231/tasks/abc231_e)\n\n一道贪心题……\n<!--more-->\n感觉很裸啊，模拟赛时随便乱写了个暴力递归就能过。每次找最接近钱数 $x$ 的面额 $num$，如果比钱数少那么答案为剩下 $x \\bmod num$ 钱数的答案加上 $x \\div num$。否则答案则为剩下 $num-x$ 钱数的答案加上 $1$。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nll n, m;\nll a[65];\nll ans(ll x) {\n\tif (x == 0) return 0;\n\tll minn = 1e18, num;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (llabs(x - a[i]) < minn) {\n\t\t\tminn = llabs(x - a[i]);\n\t\t\tnum = a[i];\n\t\t}\n\t}\n\tif (num > x) return ans(num - x) + 1;\n\treturn ans(x % num) + x / num;\n}\nint main() {\n\tios :: sync_with_stdio(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tcout << ans(m);\n\treturn 0;\n}\n```\n","tags":["题解"]},{"title":"Atcoder-dp_j 题解","url":"/cZ1i7CM1vRdb3uo29drVqFw9zH/","content":"[题目传送门](https://atcoder.jp/contests/dp/tasks/dp_j)\n\n一道 dp 题……\n<!--more-->\n发现以前课上讲的题能水题解。\n\n在 `dp` 之前，我们需要明确以下几个东西：\n\n**状态的表示**，**状态转移方程**，**边界条件**跟**答案的表示**。\n\n### 状态的表示\n\n$dp_{i,j,k}$ 表示当有 $3$ 个寿司的盘子还剩 $i$ 个，有 $2$ 个寿司的盘子还剩 $j$ 个，有 $1$ 个寿司的盘子还剩 $k$ 个时，吃完所有寿司操作次数的期望。\n\n### 状态转移方程\n\n当 $i>0$ 时：\n$$dp_{i,j,k}=dp_{i,j,k}+dp_{i-1,j+1,k}\\times i\\div (i+j+k)$$\n当 $j>0$ 时：\n$$dp_{i,j,k}=dp_{i,j,k}+dp_{i,j-1,k+1}\\times j\\div (i+j+k)$$\n当 $k>0$ 时：\n$$dp_{i,j,k}=dp_{i,j,k}+dp_{i,j,k-1}\\times k\\div (i+j+k)$$\n当 $(i+j+k)>0$  时：\n$$dp_{i,j,k}=dp_{i,j,k}+n\\div (i+j+k)$$\n\n### 边界条件\n\n$$dp_{0,0,0}=0$$\n### 答案的表示\n$$dp_{cnt_3,cnt_2,cnt_1}$$\n其中，$cnt_i$ 表示有 $i$ 个寿司的盘子数量。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint n;\nint cnt[4];\ndouble dp[305][305][305];\nint main() {\n    ios :: sync_with_stdio(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        int x;\n        cin >> x;\n        cnt[x]++;\n    }\n    for (int i = 0; i <= cnt[3]; i++) {\n        for (int j = 0; j <= cnt[2] + cnt[3]; j++) {\n            for (int k = 0; k <= cnt[1] + cnt[2] + cnt[3]; k++) {\n                if (i == 0 and j == 0 and k == 0) continue;\n                if (i > 0) dp[i][j][k] += dp[i - 1][j + 1][k] * i / (i + j + k);\n                if (j > 0) dp[i][j][k] += dp[i][j - 1][k + 1] * j / (i + j + k);\n                if (k > 0) dp[i][j][k] += dp[i][j][k - 1] * k / (i + j + k);\n                dp[i][j][k] += 1.0 * n / (i + j + k);\n            }\n        }\n    }\n    printf(\"%.10lf\", dp[cnt[3]][cnt[2]][cnt[1]]);\n    return 0;\n}\n```\n\n","tags":["题解"]},{"title":"洛谷-B3608 题解","url":"/JeEb5hYmQiq3XJo4N2sZFKoea6/","content":"[题目传送门](https://www.luogu.com.cn/problem/B3608)\n\n一道网络流题……\n<!--more-->\n费用流板子题。费用流实际上是在给最大流套个最短路，而费用流一般边权会有负数，所以用 SPFA 算法，~~关于 SPFA，它复活了~~。\n\n可以在最大流做 bfs 的时候将 SPFA 套上去。数据似乎比较凶残，建议使用 Dinic 来求最大流。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\nnamespace xvl_ { \n    #define ll long long\n    #define IMAX 1e9\n    #define LMAX 1e18\n    void debug() { std :: cerr << \"debug\" << \"\\n\"; } \n    template <typename T> inline T Max(T a, T b) { return a > b ? a : b; }\n    template <typename T> inline T Min(T a, T b) { return a < b ? a : b; }\n    template <typename T, typename... Args> inline T Max(T a, Args... args) { return a > Max(args...) ? a : Max(args...); }\n    template <typename T, typename... Args> inline T Min(T a, Args... args) { return a < Min(args...) ? a : Min(args...); }\n}\nusing namespace std;\nusing namespace xvl_;\nstruct Edge { ll to, r, c, cp; };\nll n, m, s, t, ans1, ans2;\nll dis[405], vis[405];\nbool inq[405], isz[405];\nvector <Edge> G[405];\nvoid Add_Edge(ll u, ll v, ll c, ll w) {\n    G[u].push_back({v, c, w, (int)(G[v].size())});\n    G[v].push_back({u, 0, -w, (int)(G[u].size() - 1)});\n}\nbool check(ll s, ll t) { \n    queue <ll> q;\n    fill(dis + 1, dis + 1 + 400, LMAX);\n    dis[s] = 0, inq[s] = 1, q.push(s);\n    while (!q.empty()) {\n        ll cur = q.front();\n        q.pop();\n        inq[cur] = 0;\n        for (auto v : G[cur]) {\n            if (dis[cur] + v.c < dis[v.to] and v.r) {\n                dis[v.to] = dis[cur] + v.c;\n                if (!inq[v.to]) inq[v.to] = 1, q.push(v.to);\n            }\n        }\n    }\n    return dis[t] != LMAX;\n}\nll aug(ll cur, ll now, ll& c) {\n    ll flow = 0;\n    if (cur == t) return now;\n    isz[cur] = 1;\n    for (ll& i = vis[cur]; i < G[cur].size(); i++) {\n        Edge& v = G[cur][i];\n        if (dis[v.to] != dis[cur] + v.c or isz[v.to] or !v.r) continue;\n        int d = aug(v.to, Min(now - flow, v.r), c);\n        v.r -= d, G[v.to][v.cp].r += d, flow += d, c += v.c * d;\n        if (flow == now) break;\n    }\n    isz[cur] = 0;\n    return flow;\n}\nint main() {\n    /*\n    freopen(\"InName.in\", \"r\", stdin);\n    freopen(\"OutName.out\", \"w\", stdout);\n    */\n    ios :: sync_with_stdio(0);\n    cin >> n >> m;\n    s = 1, t = n;\n    for (int i = 1; i <= m; i++) {\n        ll u, v, c, w;\n        cin >> u >> v >> c >> w;\n        Add_Edge(u, v, c, w);\n    }\n    while (check(s, t)) {\n        memset(vis, 0, sizeof vis);\n        ans1 += aug(s, LMAX, ans2);\n    }\n    cout << ans1 << \" \" << ans2;\n    return 0;\n}\n```\n\n","tags":["题解"]},{"title":"洛谷-P9556 题解","url":"/JeEb5hYmQiFpc1F2kHyLsi5Kh8/","content":"[题目传送门](https://www.luogu.com.cn/problem/P9556)\n\n一道模拟题……\n<!--more-->\n可以命名一个订单的结构体，然后将订单的结束时间进行排序。用一个变量模拟货物的数量，每遇到一个订单，货物的数量就会加上距离上一个订单的天数乘上 $k$。即对于第 $i$ 个订单，距离第 $i-1$ 订单货物数量增加了 $(a_{i}-a_{i-1})\\times k$。\n\n如果在模拟过程中出现货物数量不够交付，输出 `No`。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\nnamespace xvl_ { \n    #define ll long long\n    #define IMAX 1e9\n    #define LMAX 1e18\n    void debug() { std :: cerr << \"debug\" << \"\\n\"; } \n    template <typename T> inline T Max(T a, T b) { return a > b ? a : b; }\n    template <typename T> inline T Min(T a, T b) { return a < b ? a : b; }\n    template <typename T, typename... Args> inline T Max(T a, Args... args) { return a > Max(args...) ? a : Max(args...); }\n    template <typename T, typename... Args> inline T Min(T a, Args... args) { return a < Min(args...) ? a : Min(args...); }\n}\nusing namespace std;\nusing namespace xvl_;\nstruct order { int x, y; } a[105];\nll T, n, k, sum;\nbool flag;\nbool cmp(order tmp1, order tmp2) { return tmp1.x < tmp2.x;  }\nint main() {\n    /*\n    freopen(\"InName.in\", \"r\", stdin);\n    freopen(\"OutName.out\", \"w\", stdout);\n    */\n    ios :: sync_with_stdio(0);\n    cin >> T;\n    while (T--) {\n        flag = 1, sum = 0;\n        cin >> n >> k;\n        for (int i = 1; i <= n; i++) cin >> a[i].x >> a[i].y;\n        sort(a + 1, a + 1 + n, cmp);\n        for (int i = 1; i <= n; i++) {\n            sum += (a[i].x - a[i - 1].x) * k;\n            if (sum < a[i].y) flag = 0;\n            else sum -= a[i].y;\n        }\n        if (flag) cout << \"Yes\\n\";\n        else cout << \"No\\n\";\n    }\n    return 0;\n}\n```\n\n","tags":["题解"]},{"title":"CodeForces-798B 题解","url":"/jiy4NLvvWc21eG8eakMnE6FKXeLTBZ/","content":"[题目传送门](https://codeforces.com/problemset/problem/798/B)\n\n一道字符串题……\n<!--more-->\n由于 $n$ 非常小，可以暴力枚举字符串。我们可以枚举其中一个字符串 $s_i$，然后让其他的字符串变成 $s_i$，最后记录一下次数，取一个最小值即可。\n\n在枚举第二个字符串的时候可以将它再复制一份自己到后面，然后可以用 `find` 函数来统计。当然，如果找不到，这个字符串永远不可能变成 $s_i$，输出 $-1$。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n\nnamespace xvl_ { \n    #define ll long long\n    #define IMAX INT_MAX;\n    #define LMAX LONG_LONG_MAX\n    void debug() { std :: cerr << \"debug\" << \"\\n\"; } \n    template <typename T> inline T Max(T a, T b) { return a > b ? a : b; }\n    template <typename T> inline T Min(T a, T b) { return a < b ? a : b; }\n    template <typename T, typename... Args> inline T Max(T a, Args... args) { return a > Max(args...) ? a : Max(args...); }\n    template <typename T, typename... Args> inline T Min(T a, Args... args) { return a < Min(args...) ? a : Min(args...); }\n}\nusing namespace std;\nusing namespace xvl_;\nint n, ans = IMAX;\nstring s[55];\nint main() {\n    /*\n    freopen(\"InName.in\", \"r\", stdin);\n    freopen(\"OutName.out\", \"w\", stdout);\n    */\n    ios :: sync_with_stdio(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> s[i];\n    for (int i = 1; i <= n; i++) {\n        int cnt = 0;\n        for (int j = 1; j <= n; j++) {\n            if ((s[j] + s[j]).find(s[i]) != -1) cnt += (s[j] + s[j]).find(s[i]); // 加上次数\n            else {\n                cout << -1; // 无解\n                return 0;\n            }\n        }\n        ans = Min(ans, cnt); \n    }\n    cout << ans;\n    return 0;\n}\n```\n\n","tags":["题解"]},{"title":"洛谷-P9503 题解","url":"/JeEb5hYmQiFpc1BjK1xUMHfB2v/","content":"[题目传送门](https://www.luogu.com.cn/problem/P9503)\n\n一道模拟题……\n<!--more-->\n并不复杂的模拟题，也不需要用到贪心。\n\n我们可以创建一个数组来记录每个幕布是否被拉上，统计答案的时候，就看看这块幕布前面有多少个没拉上的，最后如果这块幕布拉上了，就重新放下来就行了。\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nll n, ans;\nstring s;\nbool vis[4]; // vis[i] = 1 表示第 i 个幕布当前是拉起来的\nint main() {\n    ios :: sync_with_stdio(0);\n    cin >> n >> s;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'W') {\n            if (vis[3]) {\n                ans++;\n                vis[3] = 0;\n            }\n        }\n        else if (s[i] == 'B') {\n            if (!vis[3]) {\n                ans++;\n                vis[3] = 1;\n            }\n            if (vis[2]) {\n                ans++;\n                vis[2] = 0;\n            }\n        }\n        else {\n            if (!vis[3]) {\n                ans++;\n                vis[3] = 1;\n            }\n            if (!vis[2]) {\n                ans++;\n                vis[2] = 1;\n            }\n            if (vis[1]) {\n                ans++;\n                vis[1] = 0;\n            }\n        }\n    }\n    cout << ans;\n    return 0;\n}\n```\n\n","tags":["题解"]},{"title":"CodeForces-531B1 题解","url":"/2oMtwNqsh8bCr3r6RSLLhofwv3ZN1T5g/","content":"[题目传送门](https://codeforces.com/problemset/problem/513/B1)\n\n一道枚举题……\n<!--more-->\n数据范围非常小，考虑暴力枚举全排列。\n\n可以 `dfs` 两次，第一次求出能使 $f(p)$ 取得的最大值。第二次求出第 $m$ 个排列。\n\n注意一下，第二次 `dfs` 的时候需要按字典序枚举。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint n, m, cnt = 1, maxf = -INF;\nint res[10];\nbool vis[10];\nvoid dfs1(int cur) {\n    if (cur > n) {\n        int sum = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = i; j <= n; j++) {\n                int minp = INF;\n                for (int k = i; k <= j; k++) minp = min(minp, res[k]);\n                sum += minp;\n            }\n        }\n        maxf = max(maxf, sum);\n        return ;\n    }\n    for (int i = 1; i <= n; i++) {\n        if (vis[i]) continue;\n        vis[i] = 1;\n        res[cur] = i;\n        dfs1(cur + 1);\n        vis[i] = 0;\n    }\n}\nvoid dfs2(int cur) {\n    if (cur > n) {\n        int sum = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = i; j <= n; j++) {\n                int minp = INF;\n                for (int k = i; k <= j; k++) minp = min(minp, res[k]);\n                sum += minp;\n            }\n        }\n        if (sum == maxf) {\n            if (cnt == m) {\n                for (int i = 1; i <= n; i++) cout << res[i] << \" \";\n                exit(0);\n            }\n            cnt++;\n        }\n        return ;\n    }\n    for (int i = 1; i <= n; i++) {\n        if (vis[i]) continue;\n        vis[i] = 1;\n        res[cur] = i;\n        dfs2(cur + 1);\n        vis[i] = 0;\n    }\n}\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> n >> m;\n    dfs1(1);\n    memset(vis, 0, sizeof(vis));\n    dfs2(1);\n    return 0;\n}\n```\n","tags":["题解"]},{"title":"C++ 常用代码集合","url":"/jdFmTQWHdesHGibnbVQLgwcSsKPgLL/","content":"会把一些常用的 C++ 代码片段写到这里，不定时更新。\n<!--more-->\n### 代码模板\n```cpp\n/*******************************************\n * Code Info\n\tAuthor: xvl_\n\tDate: Unknown\n * Problem Info\n\tOnline Judge: Unknown\n\tUrl: Unknown\n*******************************************/\n#include <bits/stdc++.h>\nnamespace xvl_ { \n\t#define ll long long\n\t#define ld long double\n\t#define IMAX 1e9\n\t#define LMAX 1e18\n\t#define SP(n, x) std :: setprecision(n) << std :: fixed << x\n\t#define Off_Sync ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\tvoid debug() { std :: cerr << \"debug\" << \"\\n\"; } \n\ttemplate <typename T> inline T Max(T a, T b) { return a > b ? a : b; } template <typename T, typename... Args> inline T Max(T a, Args... args) { return a > Max(args...) ? a : Max(args...); }\n\ttemplate <typename T> inline T Min(T a, T b) { return a < b ? a : b; } template <typename T, typename... Args> inline T Min(T a, Args... args) { return a < Min(args...) ? a : Min(args...); }\n}\nusing namespace std;\nusing namespace xvl_;\n\nint main() {\n\t// freopen(\"InName.in\", \"r\", stdin);\n\t// freopen(\"OutName.out\", \"w\", stdout);\n\tOff_Sync;\n\n\treturn 0;\n}\n```\n\n### 十进制数转二进制数\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nunsigned ll n;\nvector <int> ans;\nvoid bin(vector <int>& A, unsigned ll n) {\n    do {\n        A.push_back(n & 1);\n        n >>= 1;\n    } while (n);\n}\nint main() {\n    ios :: sync_with_stdio(0);\n    cin >> n;\n    bin(ans, n);\n    for (int i = 0; i < ans.size(); i++) cout << ans[i];\n    return 0;\n}\n```\n\n### 快速幂\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint n, m, p;\nint qpow(ll n, ll m, int p) { return !m ? 1 : ((m & 1 ? n : 1) * (m = qpow(n, m >> 1, p)) % p * m % p); }\nint main() {\n    ios :: sync_with_stdio(0);\n    cin >> n >> m >> p;\n    cout << qpow(n, m, p);\n    return 0;\n}\n```\n\n### 最长上升子序列 / LIS\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint n, ans = -INF;\nint a[5005], dp[5005];\nint main() {\n    ios :: sync_with_stdio(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    for (int i = 1; i <= n; i++) {\n        dp[i] = 1;\n        for (int j = 1; j <= i; j++) {\n            if (a[j] < a[i]) dp[i] = max(dp[i], dp[j] + 1);\n        }\n        ans = max(ans, dp[i]);\n    }\n    cout << ans;\n    return 0;\n}\n```\n\n### 最长上升子序列 / LIS （二分优化）\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint n, ans;\nint a[100005], g[100005];\nint main() {\n    ios :: sync_with_stdio(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) g[i] = INF;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    for (int i = 1; i <= n; i++) {\n        g[lower_bound(g + 1, g + ans + 1, a[i]) - g] = a[i];\n        ans = max(ans, (int)(lower_bound(g + 1, g + ans + 1, a[i]) - g));\n    }\n    cout << ans;\n    return 0;\n}\n```","tags":["算法"]},{"title":"CodeForces-513B1 题解","url":"/2oMtwNqsh8bCr3r6RSh7qByHZF3CENDr/","content":"[题目传送门](https://codeforces.com/problemset/problem/513/B1)\n\n一道枚举题……\n<!--more-->\n数据范围非常小，考虑暴力枚举全排列。\n\n可以 `dfs` 两次，第一次求出能使 $f(p)$ 取得的最大值。第二次求出第 $m$ 个排列。\n\n注意一下，第二次 `dfs` 的时候需要按字典序枚举。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint n, m, cnt = 1, maxf = -INF;\nint res[10];\nbool vis[10];\nvoid dfs1(int cur) {\n    if (cur > n) {\n        int sum = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = i; j <= n; j++) {\n                int minp = INF;\n                for (int k = i; k <= j; k++) minp = min(minp, res[k]);\n                sum += minp;\n            }\n        }\n        maxf = max(maxf, sum);\n        return ;\n    }\n    for (int i = 1; i <= n; i++) {\n        if (vis[i]) continue;\n        vis[i] = 1;\n        res[cur] = i;\n        dfs1(cur + 1);\n        vis[i] = 0;\n    }\n}\nvoid dfs2(int cur) {\n    if (cur > n) {\n        int sum = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = i; j <= n; j++) {\n                int minp = INF;\n                for (int k = i; k <= j; k++) minp = min(minp, res[k]);\n                sum += minp;\n            }\n        }\n        if (sum == maxf) {\n            if (cnt == m) {\n                for (int i = 1; i <= n; i++) cout << res[i] << \" \";\n                exit(0);\n            }\n            cnt++;\n        }\n        return ;\n    }\n    for (int i = 1; i <= n; i++) {\n        if (vis[i]) continue;\n        vis[i] = 1;\n        res[cur] = i;\n        dfs2(cur + 1);\n        vis[i] = 0;\n    }\n}\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> n >> m;\n    dfs1(1);\n    memset(vis, 0, sizeof(vis));\n    dfs2(1);\n    return 0;\n}\n```\n\n","tags":["题解"]},{"title":"CodeForces-1092C 题解","url":"/2oMtwNqsh8bCr3r6Mu7ktX9gkNs3LJNg/","content":"\n[题目传送门](https://codeforces.com/problemset/problem/1092/C)\n\n一道字符串题……\n<!--more-->\n我们考虑还原字符串后再一个一个的判断。很显然，这个字符串是由一个长度为 $n-1$ 的前缀和后缀组成的。因此我们可以找到这 $2$ 个长度为 $n$ 的字符串，然后枚举哪个是前缀，哪个是后缀。\n\n值得注意的是，当你判断一个字符串为**前缀**时，如果后面出现了同样的字符串，你只能判断它为**后缀**。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint n;\nbool flag;\nstring s1, s2, t, ans1, ans2; // t 是还原串\nstring s[205];\nmap <string, bool> mp;\nbool check1(string str) { // 判断这个字符串是否是还原串的前缀\n    for (int i = 0; i < str.size(); i++) {\n        if (t[i] != str[i]) return 0;\n    }\n    return 1;\n}\nbool check2(string str) { // 判断这个字符串是否是还原串的后缀\n    int cnt = t.size() - 1;\n    for (int i = str.size() - 1; i >= 0; i--) {\n        if (t[cnt--] != str[i]) return 0;\n    }\n    return 1;\n}\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> n;\n    for (int i = 1; i <= 2 * n - 2; i++) cin >> s[i];\n    for (int i = 1; i <= 2 * n - 2; i++) {\n        if (s[i].size() == n - 1 and flag) s2 = s[i];\n        if (s[i].size() == n - 1 and !flag) {\n            s1 = s[i];\n            flag = 1;\n        }\n    } \n    flag = 0;\n    t = s1;\n    t += s2[s2.size() - 1];\n    // 如果 s1 是前缀\n    for (int i = 1; i <= 2 * n - 2; i++) {\n        if (!check1(s[i]) and !check2(s[i])) flag = 1; // 当 s1 是前缀时不合法\n        else {\n            if (check1(s[i]) and mp.find(s[i]) == mp.end()) {\n                ans1 += 'P';\n                mp[s[i]] = 1;\n            }\n            else ans1 += 'S';\n        }\n    }\n    t = s2;\n    t += s1[s1.size() - 1];\n    // 如果 s1 是后缀\n    mp.clear();\n    for (int i = 1; i <= 2 * n - 2; i++) {\n        if (check1(s[i]) and mp.find(s[i]) == mp.end()) {\n            ans2 += 'P';\n            mp[s[i]] = 1;\n        }\n        else ans2 += 'S';\n    }\n    if (!flag) cout << ans1; \n    else cout << ans2;\n    return 0;\n}\n```\n\n","tags":["题解"]},{"title":"CodeForces-552E 题解","url":"/jiy4NLvvWc21eG8dEmid5vMq7ftkzD/","content":"\n[题目传送门](https://codeforces.com/problemset/problem/552/E)\n\n一道枚举题……\n<!--more-->\n枚举左括号和右括号的位置括号，为了答案最优，左括号只能在开头或者 `*` 的右边。右括号只能在末尾或者 `*` 的左边。每一次枚举都计算一下这个加了括号后表达式的值，最后取最大值即可。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nstring s, backup1;\nll ans, cur;\nll facrot();\nll term();\nll expr();\nll factor() {\n    ll res = 0;\n    if (s[cur] == '(') {\n        cur++;\n        res = expr();\n        cur++;\n    }\n    else {\n        while (1) {\n            if (s[cur] >= '0' and s[cur] <= '9') {\n                res = (res * 10 + s[cur] - '0');\n                cur++;\n            }\n            else break;\n        }\n    }\n    return res;\n}\nll term() {\n    ll res = factor();\n    while (1) {\n        if (s[cur] == '*') {\n            cur++;\n            res = res * factor();\n        }\n        else if (s[cur] == '/') {\n            cur++;\n            res = res / factor();\n        }\n        else break;\n    }\n    return res;\n}\nll expr() { // 表达式求值\n    ll res = term();\n    while (1) {\n        if (s[cur] == '+') {\n            cur++;\n            res += term();\n        }\n        else if (s[cur] == '-') {\n            cur++;\n            res -= term();\n        }\n        else break;\n    }\n    return res;\n} \nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> s;\n    backup1 = s;\n    for (ll i = 0; i < s.size(); i++) {\n        if (s[i] == '*' or i == 0) {\n            if (i != 0) s.insert(i + 1, \"(\", 0, 1);\n            else s.insert(i, \"(\", 0, 1);\n            string backup2 = s;\n            for (ll j = i + 1; j < s.size(); j++) {\n                if (s[j] == '*' or j == s.size() - 1) {\n                    cur = 0;\n                    if (j != s.size() - 1) s.insert(j, \")\", 0, 1);\n                    else s.insert(j + 1, \")\", 0, 1);\n                    ans = max(ans, expr());\n                }\n                s = backup2;\n            }\n        }\n        s = backup1;\n    }  \n    cout << ans;\n    return 0;\n}\n\n\n```\n\n","tags":["题解"]},{"title":"CodeForces-237C 题解","url":"/jiy4NLvvWc21eG8cV6hg5xuBsy8TMM/","content":"[题目传送门](https://codeforces.com/problemset/problem/237/C)\n\n一道二分题……\n<!--more-->\n我们需要用二分在 $O(n\\log n)$ 的时间复杂度内得到答案，也就是说我们的判断函数时间复杂度必须为 $O(n)$，因此考虑前缀和。\n\n$sum_i$ 表示出现在区间 $\\left[a,b \\right]$ 内的前 $i$ 个数中质数的数量。\n\n在二分的判断函数里，我们可以枚举左端点 $i$，用 $sum_{i-1+x} - sum_{i-1}$ 可以得到区间 $\\left[i,i-1+x \\right]$ 中质数的数量。其中，$x$ 为区间长度。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint a, b, k, ans;\nint sum[1000005];\nbool removed[1000005];\nvoid init() {\n    removed[1] = 1;\n    for (int i = 2; i * i <= b; i++) {\n        if (!removed[i]) {\n            for (int j = i * i; j <= b; j += i) removed[j] = 1;\n        }\n    }\n}   \nbool check(int x) {\n    for (int i = a; i - 1 + x <= b; i++) {\n        if (sum[i - 1 + x] - sum[i - 1] < k) return 0;\n    }\n    return 1;\n}\nvoid f(int l, int r) {\n    while (l <= r) {\n        int mid = (l + r) / 2;\n        if (check(mid)) {\n            r = mid - 1;\n            ans = mid;\n        }\n        else l = mid + 1;\n    }\n}\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> a >> b >> k;\n    init();\n    for (int i = a; i <= b; i++) {\n        sum[i] = sum[i - 1];\n        if (!removed[i]) sum[i]++;\n    }\n    f(1, 5000000);\n    if (ans <= b - a + 1) cout << ans;\n    else cout << -1;\n    return 0;\n}\n```\n\n","tags":["题解"]},{"title":"CodeForces-1132C 题解","url":"/2oMtwNqsh8bCr3r6Mumo7RKGpY5bLkX2/","content":"[题目传送门](https://codeforces.com/problemset/problem/1132/C)\n\n一道枚举题……\n<!--more-->\n我们可以直接枚举那 $2$ 个去掉的粉刷匠。先统计一下每个栅栏会被多少个粉刷匠刷到，然后枚举第一个被去掉的粉刷匠，然后计算剩下的粉刷匠会将每个栅栏刷到多少次，我们只需要看只能被刷 $1$ 次的栅栏就行了。\n\n接着处理一个前缀和数组，记录前 $i$ 个栅栏中有多少个只能被 $1$ 个粉刷匠刷到。然后枚举第二个被去掉的粉刷匠，然后通过前缀和用 $O(1)$ 的时间复杂度查询，别忘了加上前面第一个粉刷匠去掉后没有被刷的栅栏的数量。最后取最小值，与 $n$ 相减即是答案。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint n, q, minn = INF;\nint l[5005], r[5005], cnt[5005], sum[5005];\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> n >> q;\n    for (int i = 1; i <= q; i++) {\n        cin >> l[i] >> r[i];\n        for (int j = l[i]; j <= r[i]; j++) cnt[j]++;\n    }\n    for (int i = 1; i <= q; i++) {\n        int x = 0;\n        for (int j = l[i]; j <= r[i]; j++) cnt[j]--;\n        for (int j = 1; j <= n; j++) {\n            sum[j] = sum[j - 1];\n            if (cnt[j] == 1) sum[j]++;\n            if (cnt[j] == 0) x++;\n        }\n        for (int j = 1; j <= q; j++) {  \n            if (j == i) continue;\n            minn = min(minn, sum[r[j]] - sum[l[j] - 1] + x);\n        }\n        for (int j = l[i]; j <= r[i]; j++) cnt[j]++; // 别忘了要加回去继续枚举\n    }\n    cout << n - minn;\n    return 0;\n}\n```\n\n","tags":["题解"]},{"title":"CodeForces-402B 题解","url":"/jiy4NLvvWc21eG8dpFPkKKi4hFva66/","content":"[题目传送门](https://codeforces.com/problemset/problem/402/B)\n\n一道枚举题……\n<!--more-->\n数据范围非常小，考虑暴力枚举。枚举第一棵树的高度，如果按照这样排列需要的操作次数是**最小的**，就选用这棵树作为新的第一棵树的高度，然后求出剩下的树的高度。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint n, k, maxn = -INF, maxl = -INF, top, q; // top 是新的第一个高度\nint a[1005], b[1005];\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        maxn = max(maxn, a[i]); // 只需要枚举到最大值\n    }\n    for (int i = 1; i <= maxn; i++) {\n        int cnt = i, sum = 0; // sum 是统计以 i 这个高度为开头有多少棵树不用进行操作\n        if (i == a[1]) sum++; \n        for (int j = 2; j <= n; j++) {\n            cnt += k;\n            if (cnt == a[j]) sum++;\n        }\n        if (sum > maxl) { // 最多有多少棵树不操作\n            maxl = sum;\n            top = i;\n        }\n    }\n    b[1] = top;\n    int x = top + k;\n    for (int i = 2; i <= n; i++) {\n        b[i] = x;\n        x += k;\n    }\n    for (int i = 1; i <= n; i++) {\n        if (a[i] != b[i]) q++;\n    }\n    cout << q << \"\\n\";\n    for (int i = 1; i <= n; i++) {\n        if (a[i] < b[i]) cout << \"+ \" << i << \" \" << b[i] - a[i] << \"\\n\";    \n        if (a[i] > b[i]) cout << \"- \" << i << \" \" << a[i] - b[i] << \"\\n\";\n    }\n    return 0;\n}\n\n\n\n```\n\n","tags":["题解"]},{"title":"CodeForces-1201C 题解","url":"/2oMtwNqsh8bCr3r6MuAAw1MuoTfXTWRa/","content":"[题目传送门](https://www.luogu.com.cn/problem/CF1201C)\n\n一道二分题……\n<!--more-->\n熟悉的 $n \\le 2 \\times 10^5$，一眼二分。\n\n在 `check(x)` 函数里，我们需要判断的是在 $k$ 次操作以内是否能将 $x$ 变为中位数。显然的，我们只需要往上看，因为只有加法操作，将小的数进行操作一定不利。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nll n, k, ans;\nll a[200005], tmp[200005];\nbool check(ll x) {\n    for (int i = 1; i <= n; i++) tmp[i] = a[i];\n    ll cnt = 0, mid = n / 2 + 1;\n    cnt += x - a[mid];\n    a[mid] = x;\n    for (int i = mid + 1; i <= n; i++) {\n        if (a[i] < a[i - 1]) {\n            cnt += a[i - 1] - a[i];\n            a[i] = a[i - 1];\n        }\n    }\n    for (int i = 1; i <= n; i++) a[i] = tmp[i];\n    if (cnt <= k) return 1;\n    return 0;\n}\nvoid f(ll l, ll r) {\n    while (l <= r) {\n        ll mid = (l + r) / 2;\n        if (check(mid)) {\n            l = mid + 1;\n            ans = mid;\n        }\n        else r = mid - 1;\n    }\n}\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    sort(a + 1, a + 1 + n);\n    f(1, 2 * INF);\n    cout << ans;\n    return 0;\n}\n```\n\n","tags":["题解"]},{"title":"CodeForces-778A 题解","url":"/jiy4NLvvWc21eG8eaegnZNWx1f1vwB/","content":"[题目传送门](https://codeforces.com/problemset/problem/778/A)\n\n一道二分题……\n<!--more-->\n$|p|\\le2\\times10^6$，考虑 $O(n\\log n)$ 的算法，而又要输出最大值，不难想到二分答案。\n\n二分删除字母的数量，用一个数组将删掉的字母的下标存起来，然后判断删除字符后的 $t$ 是否是 $p$ 的子序列即可。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nstring t, p;\nint ans;\nint a[200005];\nbool removed[200005]; // removed[i] 表示 i 下标上的字母已被删除\nbool check(int x) {\n    if (x > t.size()) return 0;\n    int cnt = 0;\n    memset(removed, 0, sizeof(removed));\n    for (int i = 1; i <= x; i++) removed[a[i]] = 1;\n    for (int i = 0; i < t.size(); i++) {\n        if (removed[i + 1]) continue; \n        if (t[i] == p[cnt]) cnt++;\n    }\n    if (cnt == p.size()) return 1; \n    return 0;\n}\nvoid f(int l, int r) {\n    while (l <= r) {\n        int mid = (l + r) / 2;\n        if (check(mid)) {\n            l = mid + 1;\n            ans = mid; // 求最大值\n        }\n        else r = mid - 1;\n    }\n}\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> t >> p;\n    for (int i = 1; i <= t.size(); i++) cin >> a[i];\n    f(1, 200000);\n    cout << ans;\n    return 0;\n}\n```\n\n","tags":["题解"]},{"title":"CodeForces-388A 题解","url":"/jiy4NLvvWc21eG8daKLRojPsTDUGra/","content":"[题目传送门](https://codeforces.com/problemset/problem/388/A)\n\n一道贪心题……\n<!--more-->\n我们先将箱子的力量值从小到大排序，**优先将小的放顶上**，只要还能在底下放就放，否则就到下一个堆。\n\n为什么要从小到大往下放呢？因为越小的力量值能放的位置就越少，所以尽早放一定是最优的。相反，力量值大的选择更多。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint n, ans;\nint a[105];\nbool vis[105]; // vis[i] = 1 表示这个箱子已经用过了\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    sort(a + 1, a + 1 + n);\n    for (int i = 1; i <= n; i++) {\n        if (vis[i]) continue;\n        vis[i] = 1;\n        int cnt = 1; // 当前最顶上有 1 个\n        for (int j = i + 1; j <= n; j++) {\n            if (!vis[j] and cnt <= a[j])  {\n                vis[j] = 1;\n                cnt++;\n            }\n        }\n        ans++;\n    }\n    cout << ans;\n    return 0;\n} \n\n\n```\n\n","tags":["题解"]},{"title":"CodeForces-494A 题解","url":"/jiy4NLvvWc21eG8dqcaLWJm7pULRvM/","content":"[题目传送门](https://codeforces.com/problemset/problem/494/A)\n\n一道贪心题……\n<!--more-->\n贪心策略是除了最后一个 `#` 其他的都变成 $1$ 个 `)`，这样前面的 `)` 就尽可能的少，最后的 `#` 变成的 `)` 数量加上前面的 `)` 数量等于 `(` 的数量，这样在最后所有的括号都会匹配。最后检查一下合不合法。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nstring s, tmp;\nint sum1, sum2, sum3, sum4, cnt, last; // sum1 和 sum2 用来判断最后一个 # 要变成多少个 )\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> s;\n    if (s.size() == 1) {\n        cout << -1;\n        return 0;\n    } // 如果只有 1 个字符必然无解\n    for (int i = s.size() - 1; i >= 0; i--) {\n        if (s[i] == '#') {\n            cnt++;\n            last = i;\n            break;\n        }\n    }\n    for (int i = 0; i < s.size(); i++) {\n        if (i == last) continue; // 最后一个 # 先不处理\n        if (s[i] == '(') sum1++; \n        else if (s[i] == ')') sum2++;\n        else {\n            cnt++;\n            s[i] = ')';\n            sum2++;\n        }\n    }\n    if (sum1 == sum2) {\n        cout << -1;\n        return 0;\n    } // 必然无解，因为 # 必须变成 1 个以上的 )\n    for (int i = 1; i <= sum1 - sum2; i++) tmp += ')';\n    s.replace(last, 1, tmp);\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '(') sum3++;    \n        if (s[i] == ')') sum4++;\n        if (sum4 > sum3) {\n            cout << \"-1\";\n            return 0;\n        }\n    } // 判断是否合法\n    for (int i = 1; i <= cnt; i++) {\n        if (i == cnt) cout << sum1 - sum2;\n        else cout << 1 << \"\\n\"; \n    } // 贪心策略\n    return 0;\n}\n```\n\n","tags":["题解"]},{"title":"CodeForces-1194C 题解","url":"/2oMtwNqsh8bCr3r6MumHGiSv2HMY7Zpr/","content":"\n[题目传送门](https://codeforces.com/problemset/problem/1194/C)\n\n一道模拟题……\n<!--more-->\n首先判断 $s$ 是否是 $t$ 的子序列，如果不是就直接输出 `NO`。证明一下，$s$ 一定是 $s$ 插入 $p$ 后得到的字符串的子序列，但如果 $s$ 不是 $t$ 的子序列，则插入后的字符串一定不等于 $t$。\n\n如果 $s$ 是 $t$ 的子序列，我们统计一下 $t$ 中的其他字符共有多少个，如果 $p$ 中的数量足够就输出 `YES`，否则输出 `NO`。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint q, numt[30], nump[30];\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> q;\n    while (q--) {\n        memset(numt, 0, sizeof(numt));\n        memset(nump, 0, sizeof(nump));\n        int cnt = 0;\n        string s, t, p;\n        cin >> s >> t >> p;\n        for (int i = 0; i < t.size(); i++) {\n            if (t[i] == s[cnt]) cnt++;\n        }\n        if (cnt != s.size()) cout << \"NO\\n\";\n        else {\n            bool flag = 1;\n            cnt = 0;\n            for (int i = 0; i < t.size(); i++) {\n                if (t[i] == s[cnt]) {\n                    cnt++;\n                    continue;\n                }\n                numt[t[i] - 'a' + 1]++;\n            }\n            for (int i = 0; i < p.size(); i++) nump[p[i] - 'a' + 1]++;\n            for (int i = 1; i <= 26; i++) {\n                if (nump[i] < numt[i]) flag = 0;\n            }\n            if (flag) cout << \"YES\\n\";\n            else cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}\n```\n","tags":["题解"]},{"title":"CodeForces-75B 题解","url":"/59vt9k9uZ8W9ErREM7xqj6RxVGf9K/","content":"[题目传送门](https://codeforces.com/problemset/problem/75/B)\n\n一道模拟题……\n<!--more-->\n用一个 `map` 存储每个人的优先级因子，然后存进 `vector` 里进行排序。难点在于分辨 $X$ 和 $Y$ 与当前是什么操作。\n\n不过需要注意，只要出现了名字就需要输出，且我们认为与你没关系的人不加分。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nstring name;\nint n, cnt;\nmap <string, int> mp;\nvector <pair <string, int>> ans; \nbool cmp(const pair <string, int> &x, const pair <string, int> &y) { // 排序\n    if (x.second != y.second) return x.second > y.second;\n    return x.first < y.first; \n}\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> name >> n;\n    cin.get(); // 接下来要 getline\n    for (int i = 1; i <= n; i++) {\n        int j;\n        string s, x, y, op;\n        getline(cin, s);\n        for (j = s.size() - 8; s[j] != ' '; j--) y += s[j]; \n        reverse(y.begin(), y.end()); // 判断 Y\n        for (j = 0; s[j] != ' '; j++) x += s[j]; // 判断 X\n        for (j++; s[j] != ' '; j++) op += s[j]; // 判断是什么操作\n        if (x != name and mp.find(x) == mp.end()) mp[x] = 0; \n        if (y != name and mp.find(y) == mp.end()) mp[y] = 0;\n        // 只要出现了就要输出\n        if (y == name) {\n            if (op == \"posted\") mp[x] += 15;\n            else if (op == \"commented\") mp[x] += 10;\n            else mp[x] += 5;\n        }\n        if (x == name) {\n            if (op == \"posted\") mp[y] += 15;\n            else if (op == \"commented\") mp[y] += 10;\n            else mp[y] += 5;\n        }\n    }\n    for (auto v : mp) ans.push_back(make_pair(v.first, v.second));\n    sort(ans.begin(), ans.end(), cmp);\n    for (auto v : ans) cout << v.first  << \"\\n\";\n    return 0;\n}\n```\n\n\n\n","tags":["题解"]},{"title":"CodeForces-985B 题解","url":"/jiy4NLvvWc21eG8eE3RVCCCy2BrRZv/","content":"[题目传送门](https://codeforces.com/problemset/problem/985/B)\n\n一道枚举题……\n<!--more-->\n首先我们需要知道什么开关才能被去掉，题目要求去掉这个开关后所有的灯依然能够开启。也就是说，**这个开关能打开的所有灯都可以由其它开关代替**。\n\n思路清晰了，就比较好做。我们可以用一个数组存储下每一盏灯可以被几个开关开启，如果有一盏灯只能被 $1$ 个开关所开启，则那个开关不能被去掉。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint n, m;\nchar a[2005][2005];\nint cnt[2005]; // cnt[i] 表示有多少个开关可以打开第 i 盏灯\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            cin >> a[i][j];\n            if (a[i][j] == '1') cnt[j]++;\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        bool flag = 0;\n        for (int j = 1; j <= m; j++) {\n            if (a[i][j] == '1') {\n                if (cnt[j] == 1) flag = 1; // 这个开关是不可去掉的\n            }\n        }\n        if (!flag) {\n            cout << \"YES\";\n            return 0;\n        }\n    }\n    cout << \"NO\";\n    return 0;\n}\n```\n\n","tags":["题解"]},{"title":"CodeForces-1266A 题解","url":"/2oMtwNqsh8bCr3r6MuAW8F2sgiiZ5neM/","content":"\n[题目传送门](https://codeforces.com/problemset/problem/1266/A)\n\n一道模拟题……\n<!--more-->\n纯模拟肯定不行，考虑优化。$60 = 2^2 \\times 3 \\times 5$，也就是说我们判断组合后的数字能否被 $2$，$3$，$10$ 整除即可。\n\n如果这个数能被 $2$ 整除，那么原数一定会存在偶数；如果这个数能被 $3$ 整除，那么它的数字和应该也能被 $3$ 整除；如果这个数能被 $10$ 整除，那么原数一定存在 $0$。\n\n值得注意的是，如果原数只出现过一个 $0$，那么该数是不能被 $10$ 和 $2$ 同时整除的。因此，我们还需要判断一下原数是否有除了 $0$ 以外的偶数或者 $2$ 个以上的 $0$。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint n;\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        string s; // 不要用 int，否则会出错\n        int sum = 0, cnt1 = 0, cnt2 = 0; // sum 是数位和，cnt1 是 0 的个数，cnt2 是除了 0 以外的偶数的个数\n        bool flag1 = 0, flag2 = 0, flag3 = 0; // flag1 判断能否被 3 整除，flag2 判断能否被 10 整除，flag3 判断能够被 2 整除\n        cin >> s;\n        for (int i = 0; i < s.size(); i++) {\n            int num = s[i] - '0';\n            sum += num;\n            if (num == 0) cnt1++;\n            else if (num % 2 == 0) cnt2++;\n        }\n        if (sum % 3 == 0) flag1 = 1;\n        if (cnt1) flag2 = 1;\n        if (cnt2 or cnt1 > 1) flag3 = 1; // 如果有两个 0 也可以\n        if (flag1 and flag2 and flag3) cout << \"red\\n\";\n        else cout << \"cyan\\n\";\n    }\n    return 0;\n}\n```\n","tags":["题解"]},{"title":"CodeForces-203B 题解","url":"/jiy4NLvvWc21eG8cUVsjoSV2QY9YjP/","content":"[题目传送门](https://codeforces.com/problemset/problem/203/B)\n\n一道模拟题……\n<!--more-->\n如果每涂一个格子就判断整个矩阵，那时间复杂度显然会炸。\n\n我们每涂一个格子，影响的应该只是以这个格子为中心的 $3 \\times 3$ 矩阵，判断以这些点为中心的话会不会涂出 $3 \\times 3$ 的矩阵即可。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint n, m;\nint dx[9] = {1, 1, 1, -1, -1, -1, 0, 0, 0}; // x 坐标变化\nint dy[9] = {0, -1, 1, 0, -1, 1, 0, -1, 1}; // y 坐标变化\nbool vis[1005][1005];\nbool check(int x, int y) {\n    for (int i = 0; i < 9; i++) {\n        if (!vis[x + dx[i]][y + dy[i]]) return 0;\n    }\n    return 1;\n}\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++) {\n        int x, y;\n        cin >> x >> y;\n        vis[x][y] = 1;\n        for (int j = 0; j < 9; j++) {\n            if (check(x + dx[j], y + dy[j])) {\n                cout << i;\n                return 0; // 直接结束程序\n            }\n        }\n    }\n    cout << -1;\n    return 0;\n}\n\n```\n\n","tags":["题解"]},{"title":"AtCoder-abc230_d 题解","url":"/2mpQoKaYxUnSVo4tpLaTPYCFeJLygEWX/","content":"[题目传送门](https://atcoder.jp/contests/abc230/tasks/abc230_d)\n\n一道贪心题……\n<!--more-->\n我们可以将每一堵墙的右端点从小到大进行排序，然后我们从第 $1$ 堵墙开始看，将在第 $1$ 堵墙的右端点打破后会倒塌的墙全部跳过，去看下一堵还没被打破的墙。可以证明这是最优解。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint n, d, ans;\nstruct xvl_ {\n    int l, r;\n    bool operator < (const xvl_& s) const {\n        return r < s.r;\n    }\n}a[200005];\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> n >> d;\n    for (int i = 1; i <= n; i++) cin >> a[i].l >> a[i].r;\n    sort(a + 1, a + 1 + n);\n    for (int i = 1; i <= n; ans++) {\n        int bk = i + 1; \n        while (a[bk].l <= a[i].r + d - 1 and bk <= n) bk++;\n        i = bk; // 前面的墙被打破了\n    }\n    cout << ans;\n    return 0;\n}\n\n/*\n0 1 2 3 4 5 7 8 9 …\n1 ---\n2       -----\n3         -------\n\n0 1 2 3 4 5 7 8 9 …\n1 ---\n2       -----\n3       ---------\n*/\n```\n","tags":["题解"]},{"title":"CodeForces-400C 题解","url":"/jiy4NLvvWc21eG8dpFMShpyWNfsrnM/","content":"[题目传送门](https://codeforces.com/problemset/problem/400/C)\n\n一道模拟题……\n<!-- more -->\n先看数据范围，$x,y,z \\le 10^9$ 显然会超时。不难看出，顺时针或逆时针旋转 $4$ 次和镜面对称 $2$ 次后会恢复原样，所以我们先对 $x,y,z$ 进行取余。\n\n$$x\\bmod 4,z\\bmod4,y\\bmod2$$\n\n然后我们观察一个矩阵顺时针旋转后坐标的变化，当你在第 $x$ 行第 $y$ 列时，旋转后应该在第 $y$ 行第 $n - x + 1$ 的位置。即 $(x, y) \\to (y, n - x + 1)$。\n\n接下来观察镜面对称与逆时针旋转，可以分别得出 $(x, y) \\to (x, m - y + 1)$ 和 $(x, y) \\to (m - y + 1, x)$\n\n值得注意的是，在顺时针或逆时针旋转后，$n$ 和 $m$ 的值需要进行交换，别忘了。\n\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint n, m, x, y, z, p;\nint X[100005], Y[100005];\nvoid solve_x() {\n    for (int i = 1; i <= p; i++) {\n        int tmp = X[i];\n        X[i] = Y[i];\n        Y[i] = n - tmp + 1; \n    }\n    swap(n, m); // 交换\n}\nvoid solve_y() {\n    for (int i = 1; i <= p; i++) Y[i] = m - Y[i] + 1;\n}\nvoid solve_z() {\n    for (int i = 1; i <= p; i++) {\n        int tmp = Y[i];\n        Y[i] = X[i];\n        X[i] = m - tmp + 1;\n    }\n    swap(n, m); // 交换\n}\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> n >> m >> x >> y >> z >> p;\n    x %= 4, y %= 2, z %= 4; // 注意取模\n    for (int i = 1; i <= p; i++) cin >> X[i] >> Y[i];\n    for (int i = 1; i <= x; i++) solve_x();\n    for (int i = 1; i <= y; i++) solve_y();\n    for (int i = 1; i <= z; i++) solve_z();\n    for (int i = 1; i <= p; i++) cout << X[i] << \" \" << Y[i] << \"\\n\";\n    return 0;\n}\n\n/*\n观察过程\n1 2 3    7 4 1\n4 5 6 -> 8 5 2\n7 8 9    9 6 3\n(1, 1) -> (1, 3) -> (3, 3) -> (3, 1) -> (1, 1)\n……\n1 2 3    3 2 1\n4 5 6 -> 6 5 4\n7 8 9    9 8 7\n(1, 1) -> (1, 3) -> (1, 1)\n……\n1 2 3    3 6 9\n4 5 6 -> 2 5 8\n7 8 9    1 4 7\n(1, 1) -> (3, 1) -> (3, 3) -> (1, 3) -> (1, 1)\n……\n*/\n\n```\n\n","tags":["题解"]},{"title":"洛谷-P3378 题解","url":"/JeEb5hYmQiFnGB4ehpuWWZtYd4/","content":"\n[题目传送门](https://www.luogu.com.cn/problem/P3378)\n\n一道小根堆模板题……\n<!-- more -->\n在做这道题之前，我们先介绍一下小根堆是什么。\n\n我们定义小根堆是一种对于任何一个**父结点**的权值总是小于或等于**子节点**权值的完全二叉树。因此，不难看出，一个小根堆的堆顶（这棵树的根节点）应该是这个堆（树）中权值**最小的**结点。\n\n简单介绍完了小根堆，我们再介绍下如何存储。\n\n### 存储\n\n我们考虑用一个数组进行存储，用一个变量来记录堆里的元素个数。\n\n```cpp\nint heap[1000005]; // 用数组存储\nint cnt; // 记录堆中的元素个数，也是下一个元素插入进来的位置\n```\n\n------------\n\n学会了如何存储小根堆，接下来我们要实现几个操作：\n\n- 插入一个数\n\n- 查询堆顶\n\n- 删除堆顶\n\n### 插入一个数\n\n我们需要在最后一个位置插入，然后从下往上进行维护。如果发现**父结点**的权值大于**子结点**的权值，则将**子结点**与**父结点**进行交换，然后继续往上进行搜索。\n\n```cpp\nvoid xds(int cur) { \n    int fa = (cur - 1) / 2; // 父亲结点的位置\n    if (heap[fa] > heap[cur]) { // 如果不合法\n        swap(heap[fa], heap[cur]); // 进行交换\n        xds(fa); // 继续往上维护\n    }\n}\nvoid insert(int x) {\n    heap[cnt] = x; // 插入\n    xds(cnt++); // 维护\n}\n```\n\n------------\n\n### 查询堆顶\n\n之前说过，堆顶应该是整个堆中最小的元素，而我们插入维护是从下往上进行维护（对于整个数组，我们可以说是从后往前进行维护）的，因此堆顶为 `heap[0]`。\n\n------------\n\n### 删除堆顶\n\n我们可以将堆顶与最后一个元素进行互换，然后将长度减 $1$，就相当于删掉了这个元素。之后我们**从上往下**维护一遍，我们分成没有子结点，有一个子结点，有两个子结点这 $3$ 种情况进行维护，原理与插入差不多。\n\n```cpp\nvoid sdx(int cur) {\n    if (2 * cur + 1 >= cnt) return ; // 没有子结点\n    if (2 * cur + 2 >= cnt) { // 有一个子结点\n        if (heap[2 * cur + 1] < heap[cur]) swap(heap[2 * cur + 1], heap[cur]);\n        return ;\n    }\n    int l = 2 * cur + 1, r = l + 1;\n    if (heap[l] > heap[r]) swap(l, r); // 确定哪个子结点跟这个结点交换\n    if (heap[l] < heap[cur]) { // 不合法\n        swap(heap[l], heap[cur]); // 交换\n        sdx(l); // 继续往下维护\n    }\n}\nvoid del() {\n    swap(heap[0], heap[--cnt]); // 删掉堆顶\n    sdx(0); // 从上往下进行维护\n}\n```\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint n;\nint heap[1000005]; // 用数组存储\nint cnt; // 记录堆中的元素个数，也是下一个元素插入进来的位置\nvoid xds(int cur) { \n    int fa = (cur - 1) / 2; // 父亲结点的位置\n    if (heap[fa] > heap[cur]) { // 如果不合法\n        swap(heap[fa], heap[cur]); // 进行交换\n        xds(fa); // 继续往上维护\n    }\n}\nvoid insert(int x) {\n    heap[cnt] = x; // 插入\n    xds(cnt++); // 维护\n}\nvoid sdx(int cur) {\n    if (2 * cur + 1 >= cnt) return ; // 没有子结点\n    if (2 * cur + 2 >= cnt) { // 有一个子结点\n        if (heap[2 * cur + 1] < heap[cur]) swap(heap[2 * cur + 1], heap[cur]);\n        return ;\n    }\n    int l = 2 * cur + 1, r = l + 1;\n    if (heap[l] > heap[r]) swap(l, r); // 确定哪个子结点跟这个结点交换\n    if (heap[l] < heap[cur]) { // 不合法\n        swap(heap[l], heap[cur]); // 交换\n        sdx(l); // 继续往下维护\n    }\n}\nvoid del() {\n    swap(heap[0], heap[--cnt]); // 删掉堆顶\n    sdx(0); // 从上往下进行维护\n}\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        int op;\n        cin >> op;\n        if (op == 1) {\n            int x;\n            cin >> x;\n            insert(x);\n        }\n        else if (op == 2) cout << heap[0] << \"\\n\";\n        else del();\n    }\n    return 0;\n}\n```\n\n\n\n","tags":["题解"]},{"title":"AtCoder-abc213_d 题解","url":"/2mpQoKaYxUnSVo4tpKFiecGaLsTu4tW4/","content":"[题目传送门](https://atcoder.jp/contests/abc213/tasks/abc213_d)\n\n一道 `dfs` 序题……\n<!-- more -->\n题目中高桥每次只会去最小的那个点，所以要先对整张图进行排序。\n\n```cpp\nfor (int i = 1; i <= n; i++) sort(g[i].begin(), g[i].end());\n```\n然后考虑 `dfs`。高桥不会走重复的点，所以我们可以开一个 `vis` 数组进行标记。然后我们需要处理高桥君如果无路可走会返回上一个点的情况。在 `dfs` 回溯后输出当前节点即可。\n\n```cpp\nvoid dfs(int cur) {\n    vis[cur] = 1;\n    cout << cur << \" \";\n    for (auto v : g[cur]) {\n        if (vis[v]) continue;\n        dfs(v);\n        cout << cur << \" \";\n    }\n}\n```\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nvector <int> g[200005];\nbool vis[200005]; // 标记高桥走过的点\nint n;\nvoid dfs(int cur) {\n    vis[cur] = 1; // 每走过一个点就标记一下\n    cout << cur << \" \"; \n    for (auto v : g[cur]) {\n        if (vis[v]) continue; // 如果已经走过了就不走了\n        dfs(v); // 注意这里要先 dfs\n        cout << cur << \" \";\n    }\n}\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    for (int i = 1; i <= n; i++) sort(g[i].begin(), g[i].end()); // 排序\n    dfs(1);\n    return 0;\n}\n```\n","tags":["题解"]},{"title":"洛谷-P8654 题解","url":"/JeEb5hYmQiFoWFK8EpY3S5quwF/","content":"[题目传送门](https://www.luogu.com.cn/problem/P8654)\n\n一道并查集模板题……\n<!-- more -->\n没什么好说的，先给个并查集模板，神犇可以直接跳过。\n\n查找根：\n\n```cpp\nint find_root(int n) {\n    if (fa[n] == n) return n;\n    return fa[n] = find_root(fa[n]);\n}\n```\n合并：\n\n```cpp\nvoid merge(int x, int y) { \n    int sx = find_root(x), sy = find_root(y);\n    if (sx != sy) fa[sx] = sy;\n}\n```\n\n预处理：\n\n```cpp\nfor (int i = 1; i <= n; i++) fa[i] = i;\n```\n题目要求有多少个集合，也就是有多少个根。简单判断即可。\n\n```cpp\nif (fa[i] == i) ans++;\n```\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint m, n, k, ans;\nint fa[1000005];\nint find_root(int n) { // 查找根\n    if (fa[n] == n) return n;\n    return fa[n] = find_root(fa[n]);\n}\nvoid merge(int x, int y) { // 合并\n    int sx = find_root(x), sy = find_root(y);\n    if (sx != sy) fa[sx] = sy;\n}\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> m >> n >> k;\n    for (int i = 1; i <= m * n; i++) fa[i] = i; // 预处理\n    for (int i = 1; i <= k; i++) {\n        int u, v;\n        cin >> u >> v;\n        merge(u, v);\n    }\n    for (int i = 1; i <= m * n; i++) {\n        if (fa[i] == i) ans++; // 如果是根，答案增加\n    }\n    cout << ans;\n    return 0;\n}\n```\n\n\n","tags":["题解"]},{"title":"CodeForces-177C1 题解","url":"/2oMtwNqsh8bCr3r6MvQUuCcgzt8rSLSx/","content":"\n[题目传送门](https://codeforces.com/problemset/problem/177/C1)\n\n一道简单的并查集练手题……\n<!-- more -->\n与普通的并查集不同，除此之外还需记录下来某两人的讨厌关系，使得他们不能在同一集合中。\n\n```cpp\nif (find_root(x) == find_root(y)) vis[find_root(x)] = 1;\n```\n剩下的就是并查集了，神犇可以直接跳过。\n\n查找根：\n\n```cpp\nint find_root(int n) {\n    if (fa[n] == n) return n;\n    return fa[n] = find_root(fa[n]);\n}\n```\n合并：\n\n```cpp\nvoid merge(int x, int y) { \n    int sx = find_root(x), sy = find_root(y);\n    if (sx != sy) fa[sx] = sy;\n}\n```\n\n预处理：\n\n```cpp\nfor (int i = 1; i <= n; i++) fa[i] = i;\n```\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nint n, k, m, ans; // ans 需初始化为 0\nint cnt[2005], fa[2005]; \nbool vis[2005]; // 标记\nint find_root(int n) { // 查找根\n    if (fa[n] == n) return n;\n    return fa[n] = find_root(fa[n]);\n}\nvoid merge(int x, int y) { // 合并\n    int sx = find_root(x), sy = find_root(y);\n    if (sx != sy) fa[sx] = sy;\n}\nsigned main() {\n    ios :: sync_with_stdio(0);\n\tcin >> n >> k;\n\tfor (int i = 1; i <= n; i++) fa[i] = i; // 预处理\n\tfor (int i = 1; i <= k; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tmerge(u, v);\n\t}\n\tfor (int i = 1; i <= n; i++) cnt[find_root(i)]++; // 统计派对人数\n\tcin >> m;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tif (find_root(x) == find_root(y)) vis[find_root(x)] = 1; // 标记关系\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!vis[find_root(i)]) ans = max(ans, cnt[find_root(i)]); // 如果没有讨厌的人就更新最大值\n\t}\n\tcout << ans;\n    return 0;\n}\n```\n\n","tags":["题解"]},{"title":"AtCoder-pakencamp_2021_day2_d 题解","url":"/uPWrasQYgMVtxWWPYmiFuxGAvjur2rP8D1xk7RgXPas2kyP6n/","content":"\n[题目传送门](https://atcoder.jp/contests/pakencamp-2021-day2/tasks/pakencamp_2021_day2_d)\n\n由于数据问题，我们可以使用 `C++STL` 里的 `map` 存储企鹅君选择的答案以及次数……\n<!-- more -->\n先定义一个 `map`，用来储存答题情况。接着将企鹅君的答案存入 `map`，顺便求出最大值。\n\n```cpp\nmaxans = max(maxans, mp[x]);\n```\n\n在计算最小值的的答案之前，需要进行特判，因为题目中 $M$ 的数据达到了可怕的 $10^9$，这也是为什么我们要选择使用 `map` 的原因。\n\n当 $M > N$ 时，说明在 $M$ 个答案中，其中有一个选项企鹅君必定没有选到，而最小值只能为 $0$。\n\n```cpp\nif (m > n) minans = 0;\n```\n\n否则求剩下的最小值答案即可。\n\n```cpp\nelse {\n    for (int i = 1; i <= m; i++) minans = min(minans, mp[i]);\n}\n```\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1e9\nusing namespace std;\nmap<int, int> mp;\nint n, m, minans = INF, maxans = -INF;\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        int x;\n        cin >> x;\n        mp[x]++;\n        maxans = max(maxans, mp[x]);\n    }\n    if (m > n) minans = 0;\n    else {\n        for (int i = 1; i <= m; i++) \n            minans = min(minans, mp[i]);\n    }\n    cout << minans << ' ' << maxans;\n    return 0;\n}\n```\n\n\n\n\n","tags":["题解"]},{"title":"CodeForces-946C 题解","url":"/jiy4NLvvWc21eG8eDPQFCFmHcGEA6H/","content":"\n[题目传送门](https://codeforces.com/problemset/problem/946/C)\n\n看到各位大佬都在发题解，我也来~~水~~一篇。\n\n关于这道题，我们首先要理解一下题目……\n<!-- more -->\n> 该子序列可以通过删除掉变换后的 $s$ 中的某些字母得到。\n\n从这句话中可以知道，变换后的字符串 $s$ 只需要**包含** $a\\thicksim z$ 即可，**并不需要为连续子序列**。\n\n我们可以定义一个字符变量，初始值为 $a$，代表进度（下一个满足要求的 $s_i$ 会变换成进度）。然后遍历一遍字符串 $s$，如果 $s_i$ 小于进度，说明满足要求，可以转变，记得进度也要增加，其他的则不能。而如果当前进度已经大于 $z$，说明字符串 $s$ 已经包含 $a\\thicksim z$，那么此时可以直接跳出循环。\n\n最后我们判断一下，如果进度小于等于 $z$，证明并没有跳出循环，字符串 $s$ 不满足要求，输出 `-1`。否则，代表字符串 $s$ 满足要求，直接输出 $s$ 即可。\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nstring s;\nchar c = 'a';\nsigned main() {\n\tios :: sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin >> s;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (c > 'z') break;\n\t\tif (s[i] <= c) {\n\t\t\ts[i] = c;\n\t\t\tc++;\n\t\t}\n\t}\n\tif (c <= 'z') cout << -1;\n\telse cout << s;\n\treturn 0;\n}\n```\n\n","tags":["题解"]},{"title":"AtCoder-dp_l 题解","url":"/cYZZF3XvKUcn7SA7zRb6ihaA7X/","content":"\n[题目传送门](https://atcoder.jp/contests/dp/tasks/dp_l)\n\n一道区间 `dp` 题……\n<!-- more -->\n在 `dp` 之前，我们需要明确以下几个东西：\n\n**状态的表示**，**状态转移方程**，**边界条件**跟**答案的表示**。\n\n### 状态的表示\n定义 $sum(l,r) = \\sum_{i=l}^ra_i$ \n\n$dp_{l,r}$ 表示目前剩下的数为 $a_l \\thicksim a_r$ 时，当前取数的人取数所能获得的最大数字和。\n\n### 状态转移方程\n\n$$dp_{l,r}=\\max\\begin{cases}sum(l,r)-dp_{l+1,r}\\\\\nsum(l,r)-dp_{l,r-1}\\end{cases}$$\n\n### 边界条件\n\n$$dp_{i,i} = a_i\\space (1\\le i\\le n)$$\n\n### 答案的表示\n\n$$dp_{1,n}-(sum(1,n)-dp_{1,n})$$\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n, ans, sum[3005], a[3005], dp[3005][3005];\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0); // 优化\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        sum[i] = sum[i - 1] + a[i]; // 注意要用前缀和，否则会 TLE\n    }\n    for (int i = 1; i <= n; i++) dp[i][i] = a[i];\n    for (int len = 2; len <= n; len++) {\n        for (int l = 1, r = l + len - 1; r <= n; l++, r++) {\n            dp[l][r] = max(sum[r] - sum[l - 1] - dp[l + 1][r], sum[r] - sum[l - 1] - dp[l][r - 1]); // 进行 dp\n        }\n    }\n    cout << dp[1][n] - (sum[n] - dp[1][n]);\n    return 0;\n}\n```\n\n","tags":["题解"]},{"title":"AtCoder-abc130_e 题解","url":"/2mpQoKaYxUnSVo4toEFXNtSxMvN5DzNc/","content":"[题目传送门](https://atcoder.jp/contests/abc130/tasks/abc130_e)\n\n一道二维线性 `dp` 题……\n<!-- more -->\n在 `dp` 之前，我们需要明确以下几个东西：\n\n**状态的表示**，**状态转移方程**，**边界条件**跟**答案的表示**。\n\n### 状态的表示\n\n$\\mathit{dp}_{i,j}$ 表示考虑序列 $S$ 的前 $i$ 个数字跟序列 $T$ 的前 $j$ 个数字有多少对两个子序列的内容相同。\n\n### 状态转移方程\n\n对于 $s_i$ 与 $t_j$，有以下两种情况。\n\n$1.\\space s_i=t_j$ \n\n那 $s_1 \\thicksim s_i$ 跟 $t_1 \\thicksim t_j$ 的公共子序列有包含 $s_i$ 跟 $t_j$，包含 $s_i$ 但不包含 $t_j$，不包含 $s_i$ 跟 $t_j$，不包含 $s_i$ 但包含 $t_j$ 这 $4$ 种可能。\n\n$$\\mathit{dp}_{i,j} = \\mathit{dp}_{i-1,j} + \\mathit{dp}_{i,j-1}$$\n\n$2.\\space s_i\\ne t_j$\n\n那 $s_1 \\thicksim s_i$ 跟 $t_1 \\thicksim t_j$ 的公共子序列有包含 $s_i$ 但不包含 $t_j$，不包含 $s_i$ 跟 $t_j$，不包含 $s_i$ 但包含 $t_j$ 这 $3$ 种可能。\n\n$$\\mathit{dp}_{i,j} = \\mathit{dp}_{i-1,j} + \\mathit{dp}_{i,j-1} - \\mathit{dp}_{i-1,j-1}$$\n\n### 边界条件\n\n$$\\mathit{dp}_{i,0}=0\\;(0\\le i\\le n)$$\n\n$$\\mathit{dp}_{0,j}=0\\space \\space (\\space 0\\le j\\le m)$$\n\n### 答案的表示\n$$\\mathit{dp}_{n,m}$$\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n#define mod 1000000007\nusing namespace std;\nint n, m, s[2005], t[2005], dp[2005][2005];\nsigned main() {\n    ios :: sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0); // 优化\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) cin >> s[i];\n    for (int i = 1; i <= m; i++) cin >> t[i];\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= m; j++) {\n            if (i == 0 or j == 0) dp[i][j] = 1; // 初始化\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (s[i] == t[j]) dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod;\n            else dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]) % mod; \n        }\n        // 进行 dp\n    }\n    cout << (dp[n][m] % mod + mod) % mod; // 处理负数\n    return 0;\n}\n```\n\n","tags":["题解"]},{"title":"洛谷-P8841 题解","url":"/JeEb5hYmQiFoWNfnQnPDWaWM4z/","content":"[题目传送门](https://www.luogu.com.cn/problem/P8841)\n\n这道题主要考察的是 \"打擂台\" 算法，\n\n也就是求最大或求最小值……\n<!-- more -->\n就像这样：\n\n```cpp\nif (x > maxn) maxn = x;\n```\n也可以写成这样：\n\n```cpp\nmaxn = max(maxn, x);\n```\n\n最小值同理。\n\n然而光求出最大最小值还不行，还必须求出每个人更新后的得分，计算方法题目已经给我们了，如下：\n$$100 \\times \\frac{a_i-a_{min}}{a_{max}-a_{min}}$$\n\n最后注意一个点，题目原文说：\n\n>由于成绩系统的问题，最终录入的成绩只能是整数，**采用直接去掉小数部分的方法**。\n\n所以最后直接强转成 ```int``` 即可。\n\n\n### Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint a[1005];\nint main() {\n    int n;\n    double a_max = -1e9, a_min = 1e9; // 分别代表最大值与最小值，也要注意是 double 类型，否则计算结果是整数。\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n    \tcin >> a[i];\n    \tif (a[i] > a_max) a_max = a[i]; // 求最大值。\n    \tif (a[i] < a_min) a_min = a[i]; // 求最小值。\n    }\n    for (int i = 1; i <= n; i++) cout << (int)(100 * ((a[i] - a_min) / (a_max - a_min))) << \" \"; // 直接套公式，注意强转 int 。\n    return 0; // 最后收尾。\n}\n```\n\n总结：\n\n易错点只有最后要强转成 ```int``` 一个，其他的并不需要特别注意。\n","tags":["题解"]},{"title":"洛谷-P8840 题解","url":"/JeEb5hYmQiFoWNfnEF9D8msaN4/","content":"[题目传送门](https://www.luogu.com.cn/problem/P8840)\n\n这是一道非常适合新手练习的**分支结构**题，\n\n按照题意模拟即可……\n<!-- more -->\n### Code\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n    int t;\n    cin >> t;\n    for (int i = 1; i <= t; i++) {\n    \tint a, p;\n    \tcin >> a >> p;\n    \tif (p < 16) a -= 10; // 若是报告字数低于 16 页，则扣 10 分，如果分数低于 0 分了，则记作 0 分。\n    \tif (p > 20) a -= p - 20; // 若是报告字数超过 20 页，每超过 1 页扣 1 分 ，直到分数扣到 0 分为止。\n    \tif (a <= 0) cout << 0 << endl; // 加个特判，如果分数被扣成了负数，还是输出 0。\n    \telse cout << a << endl;\n    }\n    return 0; // 最后收尾\n}\n```\n\n总结：\n\n只需要按照题目要求写下分支结构即可，这题并没有什么难点，可以放心大胆地~~食用~~。\n","tags":["题解"]},{"title":"Welcome to my blog!","url":"/gZZ1H9orGu8utp2VYo31AGsmz8/","content":"这里是 xvl_ 的个人博客。\n[洛谷](https://www.luogu.com.cn/user/760266)\n[博客园](https://home.cnblogs.com/u/xvl-)\n[哔哩哔哩](https://space.bilibili.com/548124652?spm_id_from=333.1007.0.0)\n欢迎。\n","tags":["休闲"]}]